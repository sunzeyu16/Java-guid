

JavaScript非常受欢迎，作为函数式编程语言，它非常适合用来 11 学习数据结构和算法。通过它来学习数据结构比C或Java这些标准语言更简单，学习新东西也会 变得很有趣。

学习数据结构和算法十分重要。首要原因是数据结构和算法可以很高效地解决常见问题，这 对你今后所写代码的质量至关重要(也包括性能;要是用了不恰当的数据结构或算法，很可能会 产生性能问题)。其次，对于计算机科学，算法是最基础的概念。最后，如果你想入职最好的IT 公司(如谷歌、亚马逊、eBay等)，数据结构和算法是面试问题的重头戏。

# 数据结构
## JavaScript 面向对象编程

```
	第一种方式：
	var obj = new Object();

	第二种方式是:
	var obj = {};
	  也可以这样创建一个完整的对象:
	obj = { 
		name: {
	        first: 'Gandalf',
	        last: 'the Grey'
	    },
	    address: 'Middle Earth'
	};
```

## 原型方法
function Book(title, pages, isbn){
      this.title = title;
      this.pages = pages;
      this.isbn = isbn;

      # printTitle函数只会创建一次，在所有实例中共享.使用原型方法可以节约内存和降低实例化的开销。
      # 不过原型方法只能声明公共函 数和属性，而类定义可以声明只在类的内部访问的私有函数和属性。ECMAScript 6 引入了一套既像类定义又基于原型的简化语法。
      this.printIsbn = function(){
      console.log(this.isbn);
      }
    }
    book.printIsbn();


## ES6 和 ES7 的向下兼容性
我需要把现有的JavaScript代码更新到ES6或ES7吗?当然不用!ES6和ES7是JavaScript语言的子集。所有ES5规范的特性都可以继续使用。不过，你可以开始使用ES6和ES7的新语法，让代码 变得更简单易读。
在本书接下来的章节中，我们会尽可能地使用ES6和ES7。如果你想使用ES5编写示例代码， 可以用Babel把书中的代码转译到ES5。

## 用栈解决问题
栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常(后面的章节也会介绍)。
既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。

## 双向链表
双向链表提供了两种迭代列表的方法:从头到尾，或者反过来。我们也可以访问一个特定节 点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表 起点，重新开始迭代。这是双向链表的一个优点。

## 集合
集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。

## 集合操作 对集合可以进行如下操作。
 并集:对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
 交集:对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
 差集:对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。
 子集:验证一个给定集合是否是另一集合的子集。

## 字典和散列表
散列和字典这两种非顺序数据结构，使用字典和散列表来存储唯一值(不重复的值)的数据结构。
集合、字典和散列表可以存储不重复的值。
在集合中，我们感兴趣的是每个值本身，并把它 当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样(也是以[键， 值]对的形式来存储数据)。但是两种数据结构的实现方式略有不同。

### 字典
你已经知道，集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。
在本章中，我们会介绍几个在现实问题上使用字典数据结构的例子:一个实际的字典(单词 和它们的释义)以及一个地址簿。

### 散列
散列算法的作用是尽可能快地在数据结构中找到一个值。

## 树
学习另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用。
树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图

### 树的相关术语
<a href="image/tree-name.jpg">树的相关术语</a>

### 二叉树和二叉搜索树
二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。
二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值，在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。

### 树的遍历
遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做 呢?应该从树的顶端还是底端开始呢?从左开始还是从右开始呢?访问树的所有节点有三种方 式:中序、先序和后序。

#### 中序遍历
中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。

#### 先序遍历
先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构 化的文档。

#### 后序遍历
后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。

### 搜索树中的值
最大、最小，特定值

## AVL树（自平衡二叉树）
AVL树是一种自平衡二叉搜索树，意思是任何 一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成 为一棵完全树。

### 更多关于二叉树的知识
尽管AVL树是自平衡的，其插入或移除节点的性能并不总是最好的。更好的选择是红黑树。
红黑树可以高效有序地遍历其节点 (http://goo.gl/OxED8K) 。本书不打算讲解红黑树，但也提供了它的源代码。
如果感兴趣的话，你还可以了解堆积树 (http://goo.gl/SFlhW6) 。

## 图的相关术语
图是网络结构的抽象模型。图是一组由边连接的节点(或顶点)。学习图是重要的，因为任
何二元关系都可以用图来表示。 任何社交网络，例如Facebook、Twitter和Google plus，都可以用图来表示。 我们还可以使用图来表示道路、航班以及通信状态。

## 有向图和无向图
图可以是无向的(边没有方向)或是有向的(有向图)。

## 图的遍历
和树数据结构类似，我们可以访问图的所有节点。有两种算法可以对图进行遍历:
广度优先 搜索(Breadth-First Search，BFS) 队列
深度优先搜索(Depth-First Search，DFS) 栈

图遍历可以用来 寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。


# 排序和搜索算法
排序和搜索算法广泛地运用在待解决的日常问题中。
最常用的排序和搜索算法，如冒泡排序、选择排序、插入排序、归并排序、
快速排序和堆排序，以及顺序搜索和二分搜索算法。

## 排序
### 冒泡排序
人们开始学习排序算法时，通常都先学冒泡算法，因为它在所有排序算法中最简单。然而，
从运行时间的角度来看，冒泡排序是最差的一个，接下来你会知晓原因。
冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至 正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。

### 选择排序
选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并
将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。

### 插入排序
插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着， 它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢?这样，头两项就已正确排 序，接着和第三项比较(它是该插入到第一、第二还是第三的位置呢?)，以此类推。

### 归并排序
归并排序是第一个可以被实际使用的排序算法。你在本书中学到的前三个排序算法性能不好，但归并排序性能不错，其复杂度为O(nlogn)。

### 快速排序
快速排序也许是最常用的排序算法了。它的复杂度为O(nlogn)，且它的性能通常比其他的复 杂度为O(nlogn)的排序算法要好。和归并排序一样，快速排序也使用分治的方法，将原始数组分 为较小的数组(但它没有像归并排序那样将它们分割开)。
  快速排序比到目前为止你学过的其他排序算法要复杂一些。

### 计数排序、桶排序和基数排序(分布式排序)
到目前为止，你已经学习了如何在不借助任何辅助数据结构的情况下对数组进行排序。还有 一类被称为分布式排序的算法，原始数组中的数据会分发到多个中间结构(桶)，再合起来放回 原始数组。
  最著名的分布式算法有计数排序、桶排序和基数排序。这三种算法非常相似。

## 搜索
### 顺序搜索
顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。

### 二分搜索
二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个1到100的数字”的
游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。
这个算法要求被搜索的数据结构已排序。

# 算法模式
递归，还将学习动态规划和贪心算法。此外，我们还会介绍一 些著名的问题。

## 递归 
递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。递归通常涉及函数调用自身。

## 动态规划 （相互依赖的子问题）
动态规划(Dynamic Programming，DP)是一种将复杂问题分解成更小的子问题来解决的优化技术。
要注意动态规划和分而治之(归并排序和快速排序算法中用到的那种)是不同的方法。
分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。

遵循三个步骤
(1) 定义子问题;
(2) 实现要反复执行来解决子问题的部分(这一步要参考前一节讨论的递归的步骤);
(3) 识别并求解出边界条件。

一些著名的问题
 背包问题:给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个 问题的限制是，总容量必须小于等于“背包”的容量。
 最长公共子序列:找出一组序列的最长公共子序列(可由另一序列删除元素但不改变余 下元素的顺序而得到)。
 矩阵链相乘:给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法(计算次数尽可 能少)。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序。
 硬币找零:给出面额为d1...dn的一定数量的硬币和要找零的钱数，找出有多少种找零的 方法。
 图的全源最短路径:对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。我们在第9章 已经学习过这个问题的Floyd-Warshall算法。

## 贪心算法
贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择(当前最好的解)，从而达到全局的最优(全局最优解)。它不像动态规划算法那样计算更大的格局。
在Google、Amazon、Microsoft、Oracle等大公司的编程面试中，这些问题及 其解决方案非常常见。

## JavaScript 函数式工具箱—— map、filter 和 reduce
Page 207

## 算法模式总结
你了解了更多递归的知识，以及它如何帮助我们解决一些动态规划问题。我们介
绍了最著名的动态规划问题，如最少硬币找零问题、背包问题、最长公共子序列和矩阵链相乘。
  你学习了贪心算法，以及如何用贪心算法解决最少硬币找零问题和分数背包问题。
你还学习了函数式编程，并通过一些例子了解了如何以这种范式使用JavaScript的功能。

# 算法复杂度 （重点）
我们要学习著名的大O表示法(第10章提到过)和NP完全理论，还要看看如何用算法增添乐趣，巩固知识，提高我们编程和解决问题的能力。

符号 			名称
O(1)			常数的 
O(log(n))		对数的 
O((log(n))c)	对数多项式的 
O(n)			线性的
O(n2)			二次的 
O(nc)			多项式的 
O(cn)			指数的

理解大O表示法 如何衡量算法的效率?通常是用资源，例如CPU(时间)占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU(时间)占用。 让我们试着用一些例子来理解大O表示法的规则。




























